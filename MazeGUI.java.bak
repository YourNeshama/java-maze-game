import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Stack;
import java.util.HashSet;
import java.util.Set;

public class MazeGUI extends JFrame {
    private Maze maze;
    private int cellSize = 50;
    private int currentX = 0;
    private int currentY = 0;
    private JPanel mazePanel;
    private Stack<Point> playerPath = new Stack<>();
    private Set<Question> askedQuestions = new HashSet<>();
    private Color wallColor = new Color(64, 64, 64);
    private Color pathColor = new Color(255, 255, 255);
    private Color playerColor = new Color(0, 255, 0);
    private Color goalColor = new Color(255, 0, 0);
    private boolean isProcessingMove = false;

    public MazeGUI(Maze maze) {
        this.maze = maze;
        setTitle("Java Maze Game");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        cellSize = Math.min(50, 800 / maze.getMazeSize());
        
        mazePanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                drawMaze(g);
            }
        };
        
        mazePanel.setPreferredSize(new Dimension(
            maze.getMaze()[0].length * cellSize,
            maze.getMaze().length * cellSize
        ));

        JButton newMazeButton = new JButton("Generate New Maze");
        newMazeButton.addActionListener(e -> {
            this.maze = new Maze(maze.getMazeSize(), "easy");  // Default to easy when regenerating
            currentX = 0;
            currentY = 0;
            playerPath.clear();
            mazePanel.repaint();
            requestFocus();
        });

        JPanel controlPanel = new JPanel();
        controlPanel.add(newMazeButton);

        setLayout(new BorderLayout());
        add(mazePanel, BorderLayout.CENTER);
        add(controlPanel, BorderLayout.SOUTH);
        
        addKeyListener(new KeyAdapter() {
            @Override
            public void keyPressed(KeyEvent e) {
                handleKeyPress(e);
            }
        });
        
        setFocusable(true);
        pack();
        setLocationRelativeTo(null);
    }

    private void drawMaze(Graphics g) {
        int[][] mazeData = maze.getMaze();
        for (int row = 0; row < mazeData.length; row++) {
            for (int col = 0; col < mazeData[0].length; col++) {
                int x = col * cellSize;
                int y = row * cellSize;
                
                if (mazeData[row][col] == Maze.WALL) {
                    g.setColor(wallColor);
                } else if (row == maze.getMazeSize()-1 && col == maze.getMazeSize()-1) {
                    g.setColor(goalColor);
                } else if (mazeData[row][col] == Maze.CORRECT_PATH) {
                    g.setColor(new Color(144, 238, 144)); // Light green
                } else if (mazeData[row][col] == Maze.DEAD_END) {
                    g.setColor(new Color(255, 182, 193)); // Light pink
                } else {
                    g.setColor(pathColor);
                }
                
                g.fillRect(x, y, cellSize, cellSize);
                g.setColor(Color.BLACK);
                g.drawRect(x, y, cellSize, cellSize);
                
                // Draw player as a stick figure
                if (row == currentX && col == currentY) {
                    drawPlayer(g, x, y);
                }
            }
        }
    }
    
    private void drawPlayer(Graphics g, int x, int y) {
        int centerX = x + cellSize / 2;
        int centerY = y + cellSize / 2;
        int headSize = cellSize / 4;
        int bodyLength = cellSize / 3;
        int limbLength = cellSize / 4;
        
        // Set color to black for the stick figure
        g.setColor(Color.BLACK);
        
        // Draw head (circle)
        g.fillOval(centerX - headSize/2, centerY - bodyLength - headSize, headSize, headSize);
        
        // Draw body (vertical line)
        g.drawLine(centerX, centerY - bodyLength, centerX, centerY);
        
        // Draw arms (horizontal line)
        g.drawLine(centerX - limbLength, centerY - bodyLength/2, 
                  centerX + limbLength, centerY - bodyLength/2);
        
        // Draw legs (two diagonal lines)
        g.drawLine(centerX, centerY, centerX - limbLength, centerY + limbLength);
        g.drawLine(centerX, centerY, centerX + limbLength, centerY + limbLength);
    }

    private void handleKeyPress(KeyEvent e) {
        if (isProcessingMove) return;
        isProcessingMove = true;

        try {
            int newX = currentX;
            int newY = currentY;

            switch (e.getKeyCode()) {
                case KeyEvent.VK_UP:    newX = currentX - 1; break;
                case KeyEvent.VK_DOWN:  newX = currentX + 1; break;
                case KeyEvent.VK_LEFT:  newY = currentY - 1; break;
                case KeyEvent.VK_RIGHT: newY = currentY + 1; break;
                case KeyEvent.VK_B:
                    if (!playerPath.isEmpty()) {
                        Point lastPos = playerPath.pop();
                        if (maze.isDeadEnd(currentX, currentY)) {
                            // Reset questions around the dead end when leaving it
                            maze.resetQuestionsAroundPoint(currentX, currentY);
                        }
                        moveToPosition(lastPos.x, lastPos.y);
                        mazePanel.repaint();
                    }
                    return;
                default:
                    return;
            }

            if (maze.isValidMove(newX, newY)) {
                Question q = maze.getQuestionForCell(newX, newY);
                boolean isCorrect = false;
                
                if (q != null) {
                    isCorrect = askQuestionDialog(q);
                } else {
                    isCorrect = true;  // No question for this cell
                }

                if (isCorrect) {
                    playerPath.push(new Point(currentX, currentY));
                    moveToPosition(newX, newY);
                    maze.markPath(newX, newY, Maze.CORRECT_PATH);
                    
                    if (maze.isGoal(currentX, currentY)) {
                        JOptionPane.showMessageDialog(this, 
                            "Congratulations! You've reached the goal!", 
                            "Victory", 
                            JOptionPane.INFORMATION_MESSAGE);
                    }
                } else {
                    Point deadEnd = maze.findNearestDeadEnd(newX, newY);
                    if (deadEnd != null) {
                        System.out.println("Moving to dead end at: " + deadEnd.x + "," + deadEnd.y);
                        playerPath.push(new Point(currentX, currentY));
                        moveToPosition(deadEnd.x, deadEnd.y);
                        maze.markPath(deadEnd.x, deadEnd.y, Maze.DEAD_END);
                        JOptionPane.showMessageDialog(this,
                            "Wrong answer! Moving to nearest dead end.",
                            "Incorrect",
                            JOptionPane.ERROR_MESSAGE);
                    } else {
                        System.out.println("No dead end found!");
                        JOptionPane.showMessageDialog(this,
                            "Wrong answer! But no dead end found nearby.",
                            "Incorrect",
                            JOptionPane.ERROR_MESSAGE);
                    }
                }
                mazePanel.repaint();
            }
        } finally {
            isProcessingMove = false;
        }
    }

    private void moveToPosition(int x, int y) {
        if (maze.isValidMove(x, y)) {
            currentX = x;
            currentY = y;
            mazePanel.repaint();
        }
    }

    private boolean askQuestionDialog(Question q) {
        String answer = JOptionPane.showInputDialog(this, 
            q.getQuestion(), 
            "Answer the Question", 
            JOptionPane.QUESTION_MESSAGE);
        
        if (answer == null) return false;
        
        boolean correct = q.checkAnswer(answer);
        if (!correct) {
            JOptionPane.showMessageDialog(this,
                "Wrong answer!\nExplanation: " + q.getExplanation(),
                "Incorrect",
                JOptionPane.ERROR_MESSAGE);
        } else {
            JOptionPane.showMessageDialog(this,
                "Correct answer!\nExplanation: " + q.getExplanation(),
                "Correct!",
                JOptionPane.INFORMATION_MESSAGE);
        }
        
        return correct;
    }
} 