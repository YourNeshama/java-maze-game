<!DOCTYPE html>
<html>
<head>
    <title>Java Learning Maze Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            min-height: 100vh;
        }
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #startContent {
            background-color: white;
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
        }
        #gameContainer {
            display: none;
            margin: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .difficulty-btn {
            margin: 10px;
            padding: 15px 30px;
            font-size: 18px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.2s;
            width: 200px;
        }
        .difficulty-btn:hover {
            transform: scale(1.05);
        }
        #easyBtn {
            background-color: #4CAF50;
            color: white;
        }
        #mediumBtn {
            background-color: #FFA500;
            color: white;
        }
        #hardBtn {
            background-color: #f44336;
            color: white;
        }
        canvas {
            border: 2px solid #333;
            margin: 10px 0;
        }
        #gameStats {
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 5px;
        }
        #questionCounter {
            font-size: 18px;
            color: #333;
            margin: 10px 0;
        }
        #newGameBtn {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #newGameBtn:hover {
            background-color: #1976D2;
        }
        #regenerateMazeBtn {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #regenerateMazeBtn:hover {
            background-color: #388E3C;
        }
        h1 {
            color: #333;
            margin-bottom: 30px;
        }
        .difficulty-label {
            font-size: 14px;
            margin-top: 5px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div id="startContent">
            <h1>Java Learning Maze Game</h1>
            <p>Select your difficulty level to start:</p>
            <div>
                <button id="easyBtn" class="difficulty-btn">Easy</button>
                <div class="difficulty-label">5 Questions - Smaller Maze</div>
            </div>
            <div>
                <button id="mediumBtn" class="difficulty-btn">Medium</button>
                <div class="difficulty-label">10 Questions - Medium Maze</div>
            </div>
            <div>
                <button id="hardBtn" class="difficulty-btn">Hard</button>
                <div class="difficulty-label">15 Questions - Large Maze</div>
            </div>
        </div>
    </div>

    <div id="gameContainer">
        <h1>Java Learning Maze Game</h1>
        <div id="gameStats">
            <div id="questionCounter">Questions Remaining: 5</div>
        </div>
        <canvas id="mazeCanvas"></canvas>
        <br>
        <button id="regenerateMazeBtn">Regenerate Maze</button>
        <button id="newGameBtn">New Game</button>
    </div>

    <script>
        const WALL = 1;
        const PATH = 0;
        const CORRECT_PATH = 2;
        const DEAD_END = 3;
        
        class Question {
            constructor(question, answer, explanation) {
                this.question = question;
                this.answer = answer;
                this.explanation = explanation;
            }

            checkAnswer(userAnswer) {
                return userAnswer && userAnswer.trim().toLowerCase() === this.answer.trim().toLowerCase();
            }
        }

        class MazeGame {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.initializeGameSettings();
                this.questions = this.initializeQuestions();
                this.deadEndQuestions = this.initializeDeadEndQuestions();
                this.playerPath = [];
                this.moveQueue = [];
                this.isMoving = false;
                this.inDeadEnd = false;
                this.minPathLength = 0;

                // Initialize canvas
                this.canvas = document.getElementById('mazeCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = Math.min(40, 600 / this.size);
                this.canvas.width = this.size * this.cellSize;
                this.canvas.height = this.size * this.cellSize;

                this.initializeMaze();
                this.setupEventListeners();
                this.updateQuestionCounter();
            }

            initializeGameSettings() {
                switch(this.difficulty) {
                    case 'easy':
                        this.size = 5;
                        this.minPathLength = 5;
                        break;
                    case 'medium':
                        this.size = 7;
                        this.minPathLength = 10;
                        break;
                    case 'hard':
                        this.size = 9;
                        this.minPathLength = 15;
                        break;
                }
                this.questionsRemaining = this.minPathLength;
            }

            initializeQuestions() {
                const questions = [];
                
                // EASY questions
                questions.push(new Question(
                    "What is the size of int in bytes?\nA) 2\nB) 4\nC) 8\nD) 1",
                    "B",
                    "An int in Java is 4 bytes (32 bits)."
                ));
                questions.push(new Question(
                    "Which is the correct way to declare a variable?\nA) x = 5;\nB) int x = 5;\nC) 5 = x;\nD) variable x = 5;",
                    "B",
                    "Variables must be declared with their type in Java."
                ));
                questions.push(new Question(
                    "What is the default value of boolean?\nA) true\nB) false\nC) null\nD) 0",
                    "B",
                    "Boolean variables are initialized to false by default."
                ));

                // MEDIUM questions
                questions.push(new Question(
                    "Which is NOT an access modifier in Java?\nA) public\nB) private\nC) friendly\nD) protected",
                    "C",
                    "Java access modifiers are public, private, protected, and default (package-private)"
                ));
                questions.push(new Question(
                    "Is HashMap thread-safe in Java?\nA) Yes\nB) No\nC) Only for get operations\nD) Depends on JVM",
                    "B",
                    "HashMap is not thread-safe, use ConcurrentHashMap or Collections.synchronizedMap() instead"
                ));
                questions.push(new Question(
                    "Which collection maintains sorted order?\nA) HashSet\nB) HashMap\nC) TreeSet\nD) LinkedHashMap",
                    "C",
                    "TreeSet uses Red-Black tree implementation and maintains sorted order"
                ));

                // HARD questions
                questions.push(new Question(
                    "Which is NOT a Java garbage collector?\nA) G1\nB) CMS\nC) V8\nD) ZGC",
                    "C",
                    "V8 is a JavaScript engine, not a Java garbage collector"
                ));
                questions.push(new Question(
                    "What does volatile guarantee in Java?\nA) Atomicity\nB) Visibility\nC) Ordering\nD) B and C",
                    "D",
                    "volatile guarantees visibility and ordering but not atomicity"
                ));
                questions.push(new Question(
                    "Which collection is NOT thread-safe?\nA) Vector\nB) ConcurrentHashMap\nC) ArrayList\nD) Hashtable",
                    "C",
                    "ArrayList is not thread-safe, use Collections.synchronizedList() or CopyOnWriteArrayList"
                ));

                return questions;
            }

            initializeDeadEndQuestions() {
                const deadEndQuestions = [];
                
                deadEndQuestions.push(new Question(
                    "Can Method Area cause OutOfMemoryError?\nA) No\nB) Yes\nC) Depends on JVM version\nD) Only in 32-bit JVM",
                    "C",
                    "Before JDK8 PermGen could overflow, after JDK8 Metaspace can grow with native memory"
                ));
                deadEndQuestions.push(new Question(
                    "Which command shows Java process memory usage?\nA) jps\nB) jmap\nC) jstack\nD) jstat",
                    "B",
                    "jmap can generate heap dumps and show memory usage"
                ));
                deadEndQuestions.push(new Question(
                    "What is Unsafe class used for in Java?\nA) Security enhancement\nB) Low-level memory access\nC) Encryption\nD) Network communication",
                    "B",
                    "Unsafe provides low-level memory operations"
                ));
                deadEndQuestions.push(new Question(
                    "What is a Safepoint in Java?\nA) Security checkpoint\nB) Thread sync point\nC) GC safe point\nD) Program breakpoint",
                    "C",
                    "Safepoint is where threads must stop for GC"
                ));

                return deadEndQuestions;
            }

            initializeMaze() {
                this.maze = this.generateMaze();
                this.currentX = 0;
                this.currentY = 0;
                this.draw();
            }

            generateMaze() {
                // Initialize maze with all walls
                let maze = Array(this.size).fill().map(() => Array(this.size).fill(WALL));
                
                // Create a stack for backtracking
                let stack = [];
                let current = {x: 0, y: 0};
                
                // Set start position
                maze[0][0] = PATH;
                
                // First, create dead ends in the first 3x3 area
                let startDeadEndsCreated = 0;
                const maxStartDeadEnds = 2; // Increased from 1 to 2
                let deadEndAttempts = [
                    {x: 1, y: 1}, // center
                    {x: 1, y: 2}, // right
                    {x: 2, y: 1}, // bottom
                    {x: 1, y: 0}, // left
                    {x: 0, y: 1}, // top
                    {x: 2, y: 2}, // diagonal
                    {x: 2, y: 0}  // additional positions
                ];
                
                for (let attempt of deadEndAttempts) {
                    if (startDeadEndsCreated >= maxStartDeadEnds) break;
                    
                    // Check if we can create a dead end at this position
                    let wallCount = 0;
                    let directions = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                    
                    for (let dir of directions) {
                        let newX = attempt.x + dir.dx;
                        let newY = attempt.y + dir.dy;
                        if (newX < 0 || newX >= 3 || newY < 0 || newY >= 3 || maze[newX][newY] === WALL) {
                            wallCount++;
                        }
                    }
                    
                    // If position is suitable for a dead end (3 walls around it)
                    if (wallCount >= 3) {
                        maze[attempt.x][attempt.y] = PATH;
                        startDeadEndsCreated++;
                    }
                }
                
                // DFS maze generation with increased branching
                const visit = (x, y) => {
                    maze[x][y] = PATH;
                    
                    // Get unvisited neighbors
                    let neighbors = [];
                    let directions = [
                        {dx: -2, dy: 0},  // up
                        {dx: 2, dy: 0},   // down
                        {dx: 0, dy: -2},  // left
                        {dx: 0, dy: 2}    // right
                    ];
                    
                    // Shuffle directions randomly
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    
                    // Try all directions and collect valid neighbors
                    for (let dir of directions) {
                        let newX = x + dir.dx;
                        let newY = y + dir.dy;
                        
                        if (newX >= 0 && newX < this.size && newY >= 0 && newY < this.size && maze[newX][newY] === WALL) {
                            // Check if the path between current and new position is a wall
                            let pathX = x + dir.dx/2;
                            let pathY = y + dir.dy/2;
                            if (maze[pathX][pathY] === WALL) {
                                neighbors.push({x: newX, y: newY, dx: dir.dx/2, dy: dir.dy/2});
                            }
                        }
                    }
                    
                    return neighbors;
                };
                
                stack.push(current);
                
                while (stack.length > 0) {
                    current = stack[stack.length - 1];
                    let neighbors = visit(current.x, current.y);
                    
                    if (neighbors.length > 0) {
                        // Randomly decide to create a branch (increased probability)
                        if (Math.random() < 0.4) { // Increased from 0.3
                            // Try to create multiple branches
                            for (let i = 0; i < neighbors.length && i < 2; i++) {
                                let next = neighbors[i];
                                maze[current.x + next.dx][current.y + next.dy] = PATH;
                                stack.push({x: next.x, y: next.y});
                            }
                        } else {
                            let next = neighbors[0];
                            maze[current.x + next.dx][current.y + next.dy] = PATH;
                            stack.push({x: next.x, y: next.y});
                        }
                    } else {
                        stack.pop();
                    }
                }
                
                // Set end point and create dead ends near it
                let validEndPoints = [];
                for (let x = this.size - 2; x < this.size; x++) {
                    for (let y = this.size - 2; y < this.size; y++) {
                        if (maze[x][y] === PATH) {
                            validEndPoints.push({x, y});
                        }
                    }
                }
                
                let endPoint = validEndPoints[Math.floor(Math.random() * validEndPoints.length)];
                this.endX = endPoint.x;
                this.endY = endPoint.y;

                // Create more dead ends near the end point
                let endDeadEndsCreated = 0;
                const maxEndDeadEnds = 3; // Increased from 2 to 3
                
                // Try to create dead ends in a 5x5 area around the end point (increased from 3x3)
                for (let x = Math.max(0, this.endX - 3); x <= Math.min(this.size - 1, this.endX + 3); x++) {
                    for (let y = Math.max(0, this.endY - 3); y <= Math.min(this.size - 1, this.endY + 3); y++) {
                        if (endDeadEndsCreated >= maxEndDeadEnds) break;
                        
                        // Don't create dead end at the end point itself
                        if (x === this.endX && y === this.endY) continue;
                        
                        // Check if this position is suitable for a dead end
                        if (maze[x][y] === WALL) {
                            let adjacentPaths = 0;
                            let directions = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                            
                            for (let dir of directions) {
                                let newX = x + dir.dx;
                                let newY = y + dir.dy;
                                if (newX >= 0 && newX < this.size && newY >= 0 && newY < this.size && 
                                    maze[newX][newY] === PATH) {
                                    adjacentPaths++;
                                }
                            }
                            
                            // If exactly one adjacent path, create a dead end
                            if (adjacentPaths === 1) {
                                maze[x][y] = PATH;
                                endDeadEndsCreated++;
                            }
                        }
                    }
                }
                
                // Add more random dead ends throughout the maze
                const maxRandomDeadEnds = Math.floor(this.size * 0.8); // Increased number of random dead ends
                let randomDeadEndsCreated = 0;
                
                for (let attempts = 0; attempts < this.size * this.size && randomDeadEndsCreated < maxRandomDeadEnds; attempts++) {
                    let x = Math.floor(Math.random() * (this.size - 2)) + 1;
                    let y = Math.floor(Math.random() * (this.size - 2)) + 1;
                    
                    // Skip if too close to start or end
                    if ((x < 3 && y < 3) || 
                        (Math.abs(x - this.endX) < 3 && Math.abs(y - this.endY) < 3)) {
                        continue;
                    }
                    
                    if (maze[x][y] === WALL && this.countAdjacentPaths(maze, x, y) === 1) {
                        maze[x][y] = PATH;
                        randomDeadEndsCreated++;
                    }
                }
                
                return maze;
            }

            countAdjacentPaths(maze, x, y) {
                let count = 0;
                let directions = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                
                for (let dir of directions) {
                    let newX = x + dir.dx;
                    let newY = y + dir.dy;
                    if (newX >= 0 && newX < this.size && newY >= 0 && newY < this.size && maze[newX][newY] === PATH) {
                        count++;
                    }
                }
                
                return count;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Make cells larger for better visibility
                this.cellSize = Math.min(60, 600 / this.size);
                this.canvas.width = this.size * this.cellSize;
                this.canvas.height = this.size * this.cellSize;

                for (let row = 0; row < this.size; row++) {
                    for (let col = 0; col < this.size; col++) {
                        const x = col * this.cellSize;
                        const y = row * this.cellSize;

                        // Draw cell background
                        if (this.maze[row][col] === WALL) {
                            this.ctx.fillStyle = '#404040';
                        } else if (row === this.endX && col === this.endY) {
                            this.ctx.fillStyle = '#ff0000';
                        } else if (this.maze[row][col] === CORRECT_PATH) {
                            this.ctx.fillStyle = '#90EE90';
                        } else if (this.maze[row][col] === DEAD_END) {
                            this.ctx.fillStyle = '#FFB6C1';
                        } else {
                            this.ctx.fillStyle = '#ffffff';
                        }
                        
                        this.ctx.fillRect(x, y, this.cellSize, this.cellSize);
                        this.ctx.strokeStyle = '#000000';
                        this.ctx.strokeRect(x, y, this.cellSize, this.cellSize);
                    }
                }

                // Draw the player
                const playerX = this.currentY * this.cellSize;
                const playerY = this.currentX * this.cellSize;
                this.drawPlayer(playerX, playerY);
            }

            drawPlayer(x, y) {
                const centerX = x + this.cellSize / 2;
                const centerY = y + this.cellSize / 2;
                const headSize = this.cellSize / 4;
                const bodyLength = this.cellSize / 3;
                const limbLength = this.cellSize / 4;

                this.ctx.fillStyle = '#000000';
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                
                // Head
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY - bodyLength - headSize/2, headSize/2, 0, Math.PI * 2);
                this.ctx.fill();

                // Body
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY - bodyLength);
                this.ctx.lineTo(centerX, centerY);
                this.ctx.stroke();

                // Arms
                this.ctx.beginPath();
                this.ctx.moveTo(centerX - limbLength, centerY - bodyLength/2);
                this.ctx.lineTo(centerX + limbLength, centerY - bodyLength/2);
                this.ctx.stroke();

                // Legs
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(centerX - limbLength, centerY + limbLength);
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(centerX + limbLength, centerY + limbLength);
                this.ctx.stroke();
            }

            findPath(startX, startY, targetX, targetY) {
                // Using BFS to guarantee shortest path
                const queue = [{x: startX, y: startY, path: []}];
                const visited = new Set();
                visited.add(`${startX},${startY}`);
                
                // Define possible moves: up, right, down, left
                // Prioritize moving towards the target
                let directions = [[-1,0], [0,1], [1,0], [0,-1]];
                
                // Adjust direction priority based on target position
                if (targetY < startY) { // If target is to the left
                    directions = [[-1,0], [0,-1], [1,0], [0,1]];
                }
                if (targetX > startX) { // If target is below
                    directions = [[1,0], [0,1], [0,-1], [-1,0]];
                }
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    
                    if (current.x === targetX && current.y === targetY) {
                        return [...current.path, {x: targetX, y: targetY}];
                    }
                    
                    // Try each direction
                    for (let [dx, dy] of directions) {
                        const newX = current.x + dx;
                        const newY = current.y + dy;
                        const key = `${newX},${newY}`;
                        
                        if (this.isValidCell(newX, newY) && 
                            this.maze[newX][newY] !== WALL && 
                            !visited.has(key)) {
                            visited.add(key);
                            queue.push({
                                x: newX,
                                y: newY,
                                path: [...current.path, {x: current.x, y: current.y}]
                            });
                        }
                    }
                }
                return [];
            }

            findNearestDeadEnd(x, y) {
                const queue = [{x, y}];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    const key = `${current.x},${current.y}`;
                    
                    if (visited.has(key)) continue;
                    visited.add(key);
                    
                    if (this.isDeadEnd(current.x, current.y)) {
                        return current;
                    }
                    
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    for (let [dx, dy] of directions) {
                        const newX = current.x + dx;
                        const newY = current.y + dy;
                        
                        if (this.isValidCell(newX, newY) && this.maze[newX][newY] !== WALL) {
                            queue.push({x: newX, y: newY});
                        }
                    }
                }
                return null;
            }

            isDeadEnd(x, y) {
                if (!this.isValidCell(x, y) || this.maze[x][y] === WALL) return false;
                
                let wallCount = 0;
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                
                for (let [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    if (!this.isValidCell(newX, newY) || this.maze[newX][newY] === WALL) {
                        wallCount++;
                    }
                }
                
                return wallCount >= 3;
            }

            isValidMove(newX, newY) {
                // First check if the position is within bounds
                if (newX < 0 || newX >= this.size || newY < 0 || newY >= this.size) {
                    return false;
                }
                // Then check if it's not a wall
                return this.maze[newX][newY] !== WALL;
            }

            findShortestPathLength(x, y) {
                let visited = new Set();
                let queue = [{x: x, y: y, steps: 0}];
                visited.add(`${x},${y}`);

                while (queue.length > 0) {
                    let current = queue.shift();
                    
                    if (current.x === this.endX && current.y === this.endY) {
                        return current.steps;
                    }

                    let directions = [{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}];
                    for (let dir of directions) {
                        let newX = current.x + dir.dx;
                        let newY = current.y + dir.dy;
                        let key = `${newX},${newY}`;

                        if (this.isValidMove(newX, newY) && !visited.has(key)) {
                            visited.add(key);
                            queue.push({x: newX, y: newY, steps: current.steps + 1});
                        }
                    }
                }
                return Infinity;
            }

            async move(newX, newY) {
                if (!this.isValidMove(newX, newY)) {
                    if (newX < 0 || newX >= this.size || newY < 0 || newY >= this.size) {
                        alert("Cannot move there - out of bounds!");
                    } else {
                        alert("Cannot move there - it's a wall!");
                    }
                    return;
                }

                const question = this.getRandomQuestion();
                const correct = this.askQuestionDialog(question);
                
                if (correct) {
                    this.playerPath.push({x: this.currentX, y: this.currentY});
                    await new Promise(resolve => setTimeout(resolve, 500));
                    this.maze[this.currentX][this.currentY] = CORRECT_PATH;
                    this.currentX = newX;
                    this.currentY = newY;
                    this.maze[newX][newY] = CORRECT_PATH;
                    this.draw();
                    this.updateQuestionCounter();
                    
                    if (newX === this.endX && newY === this.endY) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                        alert("Congratulations! You've reached the goal!");
                    }
                }
            }

            isValidCell(row, col) {
                return row >= 0 && row < this.size && col >= 0 && col < this.size;
            }

            setupEventListeners() {
                // Add regenerate maze button event listener
                document.getElementById('regenerateMazeBtn').addEventListener('click', () => {
                    this.questionsRemaining = this.getInitialQuestionCount();
                    this.playerPath = [];
                    this.inDeadEnd = false;
                    this.initializeMaze();
                    this.updateQuestionCounter();
                });

                // Add existing event listeners...
                document.getElementById('easyBtn').addEventListener('click', () => startGame('easy'));
                document.getElementById('mediumBtn').addEventListener('click', () => startGame('medium'));
                document.getElementById('hardBtn').addEventListener('click', () => startGame('hard'));

                document.getElementById('newGameBtn').addEventListener('click', () => {
                    const startScreen = document.getElementById('startScreen');
                    const gameContainer = document.getElementById('gameContainer');
                    startScreen.style.display = 'flex';
                    gameContainer.style.display = 'none';
                });

                // Keyboard event listener
                document.addEventListener('keydown', async (e) => {
                    if (this.isMoving) return;
                    this.isMoving = true;

                    try {
                        let newX = this.currentX;
                        let newY = this.currentY;

                        switch (e.key) {
                            case 'ArrowUp': newX--; break;
                            case 'ArrowDown': newX++; break;
                            case 'ArrowLeft': newY--; break;
                            case 'ArrowRight': newY++; break;
                            case 'b':
                                if (!this.inDeadEnd && this.playerPath.length > 0) {
                                    const lastPos = this.playerPath.pop();
                                    await new Promise(resolve => setTimeout(resolve, 500));
                                    this.currentX = lastPos.x;
                                    this.currentY = lastPos.y;
                                    this.draw();
                                }
                                break;
                            default:
                                this.isMoving = false;
                                return;
                        }

                        if (e.key !== 'b') {
                            await this.move(newX, newY);
                        }
                    } finally {
                        this.isMoving = false;
                    }
                });

                // Make sure the game container has focus for keyboard events
                document.getElementById('gameContainer').focus();
            }

            getRandomQuestion(isDeadEnd = false) {
                if (isDeadEnd) {
                    return this.deadEndQuestions[Math.floor(Math.random() * this.deadEndQuestions.length)];
                }
                
                const availableQuestions = this.questions.slice(0, this.questionsRemaining);
                return availableQuestions[Math.floor(Math.random() * availableQuestions.length)];
            }

            updateQuestionCounter() {
                const counter = document.getElementById('questionCounter');
                const shortestPathLength = this.findShortestPathLength(this.currentX, this.currentY);
                counter.innerHTML = `${shortestPathLength} steps left`;
            }

            getInitialQuestionCount() {
                switch(this.difficulty) {
                    case 'easy': return 5;
                    case 'medium': return 10;
                    case 'hard': return 15;
                    default: return 5;
                }
            }

            askQuestionDialog(q) {
                const answer = prompt(q.question, "");
                
                if (answer === null) return false;
                
                const correct = q.checkAnswer(answer);
                if (!correct) {
                    alert("Wrong answer!\nExplanation: " + q.explanation);
                } else {
                    alert("Correct answer!\nExplanation: " + q.explanation);
                }
                
                return correct;
            }
        }

        // Game initialization
        window.onload = () => {
            const startScreen = document.getElementById('startScreen');
            const gameContainer = document.getElementById('gameContainer');
            let currentGame = null;

            // Show start screen, hide game container initially
            startScreen.style.display = 'flex';
            gameContainer.style.display = 'none';

            function startGame(difficulty) {
                startScreen.style.display = 'none';
                gameContainer.style.display = 'block';
                currentGame = new MazeGame(difficulty);
            }

            // Add click event listeners to difficulty buttons
            document.getElementById('easyBtn').addEventListener('click', () => startGame('easy'));
            document.getElementById('mediumBtn').addEventListener('click', () => startGame('medium'));
            document.getElementById('hardBtn').addEventListener('click', () => startGame('hard'));

            // Add click event listener to new game button
            document.getElementById('newGameBtn').addEventListener('click', () => {
                startScreen.style.display = 'flex';
                gameContainer.style.display = 'none';
                if (currentGame) {
                    // Clean up any existing game resources
                    currentGame = null;
                }
            });
        };
    </script>
</body>
</html> 